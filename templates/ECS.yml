AWSTemplateFormatVersion: '2010-09-09'

Description: |
  Create an ECS stack {{ project }}

### For latest ECS optomized AMIs: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html
Mappings:
  AWSRegionToAMI:
    eu-central-1:
      AMIID: ami-c123232a
    eu-west-1:
      AMIID: ami-74e7fe9e
    eu-west-2:
      AMIID: ami-e8a04a8f
    eu-west-3:
      AMIID: ami-2187375c

Resources:

  ### AWS::IAM::Role and AWS::IAM::InstanceProfile
  ECSServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['elasticloadbalancing:DeregisterInstancesFromLoadBalancer', 'elasticloadbalancing:DeregisterTargets',
              'elasticloadbalancing:Describe*', 'elasticloadbalancing:RegisterInstancesWithLoadBalancer',
              'elasticloadbalancing:RegisterTargets', 'ec2:Describe*', 'ec2:AuthorizeSecurityGroupIngress']
            Resource: '*'
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ec2.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"

      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['ecs:CreateCluster', 'ecs:DeregisterContainerInstance', 'ecs:DiscoverPollEndpoint',
              'ecs:Poll', 'ecs:RegisterContainerInstance', 'ecs:StartTelemetrySession',
              'ecs:Submit*', 'logs:CreateLogStream', 'logs:PutLogEvents', 'ecr:GetAuthorizationToken' ]
            Resource: '*'

  AutoscalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [application-autoscaling.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: service-autoscaling
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['application-autoscaling:*', 'cloudwatch:DescribeAlarms', 'cloudwatch:PutMetricAlarm',
              'ecs:DescribeServices', 'ecs:UpdateService']
            Resource: '*'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref 'EC2Role']

  ### Resources for the ECS Cluster and the Container Instances
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: "ecs-{{ project }}"

  LambdaCumulativeReservationMetric:
    Type: AWS::Lambda::Function
    Properties:
      Handler: ecs-cumulative-cpu-and-memory-reservation-metric.lambda_handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LambdaCloudWatchAndECSListExecutionRole"
      Environment:
        Variables:
          ECS_CLUSTER_NAME: "ecs-{{ project }}"
      Code:
        S3Bucket: "{{ lambda_function_bucket_name }}"
        S3Key: "aws-lambda-ecs-cumulative-cpu-and-memory-reservation-metric-8df91afee7676cb9623e6a4c37cb569425104725.zip"
      Runtime: python2.7

  LambdaPermissionCumulativeReservationMetric:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LambdaCumulativeReservationMetric.Arn
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn: !ImportValue "{{ organization.cfn_name | title }}MonitoringSubaccount-ScheduledRule5minArn"

  EventRuleECSTaskStateChange:
    Type: "AWS::Events::Rule"
    Properties:
      Description: "EventRule"
      EventPattern:
        source:
          - aws.ecs
        detail-type:
          - ECS Task State Change
        detail:
          clusterArn:
            - !GetAtt ECSCluster.Arn
      Targets:
        - Arn: !ImportValue "{{ organization.cfn_name | title}}MonitoringSubaccount-MonitoringSNSTopic"
          Id: "TargetMonitoringSNSTopic"


  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      ImageId: !FindInMap [AWSRegionToAMI, !Ref 'AWS::Region', AMIID]
      SecurityGroups:
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.SGAPP }}"
      InstanceType: "{{ ecs.cluster.instance_type }}"
      IamInstanceProfile: !Ref 'EC2InstanceProfile'
      KeyName: "{{ ecs.cluster.keypair }}"
{% if ecs.cluster.spot_price is defined %}
      SpotPrice: "{{ ecs.cluster.spot_price }}"
{% endif %}
      UserData:
        Fn::Base64:
          Fn::Sub:
          - |
            #!/bin/bash -xe
{% if ecs.efs is defined %}
            yum install -y nfs-utils
{% for fs in ecs.efs | default([]) %}
            mkdir -p {{ fs.mountpoint }}
            echo -e '{{ '${' }}{{ fs.export_name }}{{ '}' }}.efs.${AWS::Region}.amazonaws.com:/ {{ fs.mountpoint }} nfs4 nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2 0 0' >> /etc/fstab
            mount -a
{% endfor %}
{% endif %}
            echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
            yum install -y aws-cfn-bootstrap
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
          -
            dummy:
              "dummy"
{% for fs in ecs.efs | default([]) %}
            {{ fs.export_name }}:
              Fn::ImportValue:
                "{{ fs.export_name }}"
{% endfor %}


  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ1 }}"
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ2 }}"
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ3 }}"
      LaunchConfigurationName: !Ref 'ContainerInstances'
      MinSize: '{{ ecs.cluster.cluster_size.min | default('1') }}'
      MaxSize: '{{ ecs.cluster.cluster_size.max | default( [ ecs.cluster.cluster_size.max, 1 ] | max ) }}'
      DesiredCapacity: '{{ ecs.cluster.cluster_size.desired | default( [ ecs.cluster.cluster_size.min, 1 ] | max ) }}'
      Tags:
      - Key: Application
        Value: "{{ application }}"
        PropagateAtLaunch: true
      - Key: Environment
        Value: "{{ env }}"
        PropagateAtLaunch: true
      - Key: Customer
        Value: "{{ customer | default('NA') }}"
        PropagateAtLaunch: true
      - Key: ECSClusterName
        Value: "ecs-{{ project }}"
        PropagateAtLaunch: true
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'

  ### Resources for Tasks and Services
{% for app in applicationconfig %}
{%   if (app.target | lower == 'ecs') or (app.target | lower == 'ecs_scheduled_task') %}
  ### AWS::Logs::LogGroup for {{ app.name }}
  CloudWatch{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "cw-{{ project }}-{{ app.name }}"
      RetentionInDays: 14

  ### AWS::CloudWatch::MetricFilter for CloudWatch logs for application {{ app.name }}
  MetricFilterAppStart{{ cfn_project }}{{ app.cfn_name }}:
    Type: "AWS::Logs::MetricFilter"
    Properties:
      LogGroupName: !Ref CloudWatch{{ cfn_project }}{{ app.cfn_name }}
      FilterPattern: "{{ (app.monitoring | default({})).start_filter_string | default('Started Application in') }}"
      MetricTransformations:
        - MetricValue: "1"
          MetricNamespace: "{{ cfn_project }}/ServiceStart"
          MetricName: "{{ app.cfn_name }}"

{%     if app.logs_subscription_filter is defined %}
  CWSubscrFilter{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::Logs::SubscriptionFilter
    Properties:
{%       if app.logs_subscription_filter.type == 'lambda' %}
      DestinationArn: !ImportValue "{{ cfn_project }}Lambda-{{ app.logs_subscription_filter.lambda_cfn_export_name }}"
{%     endif %}
      FilterPattern: '{{ app.logs_subscription_filter.filter_pattern | default('') }}'
      LogGroupName: !Ref CloudWatch{{ cfn_project }}{{ app.cfn_name }}
{%     endif %}

{%     if app.disable_alarm is not defined or app.disable_alarm %}
  ### AWS::CloudWatch::Alarm for MetricFilterAppStart
  AlarmAppStart{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: "Start Alarm for {{ cfn_project }}{{ app.cfn_name }}"
      AlarmActions:
        - !ImportValue "{{ organization.cfn_name | title }}MonitoringSubaccount-MonitoringSNSTopic"
      MetricName: "{{ app.cfn_name }}"
      Namespace: "{{ cfn_project }}/ServiceStart"
      Statistic: Average
      Period: '60'
      EvaluationPeriods: '1'
      Threshold: '1'
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: notBreaching
{%     endif %}

  ### AWS::ECS::TaskDefinition for {{ app.name }}
  Task{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: "task-{{ project }}-{{ app.name }}"
{%     if app.ecs.volumes is defined %}
      Volumes:
{%       for volume in app.ecs.volumes %}
        - Name: {{ volume.name }}
          Host:
            SourcePath: {{ volume.hostpath }}
{%       endfor %}
{%     endif %}
      ContainerDefinitions:
        - Name: "{{ project }}-{{ app.name }}"
          Cpu: "{{ app.ecs.cpu | default('10') }}"
          Essential: 'true'
          Image: "{{ app.ecs.image }}"
          Memory: "{{ app.ecs.memory | default(1024) }}"
{%     if app.ecs.volumes is defined %}
          MountPoints:
{%       for volume in app.ecs.volumes %}
            - ContainerPath: {{ volume.containerpath }}
              SourceVolume: {{ volume.name }}
              ReadOnly: false
{%       endfor %}
{%     endif %}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref "CloudWatch{{ cfn_project }}{{ app.cfn_name }}"
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: "{{ project }}-{{ app.name }}"
          PortMappings:
            - ContainerPort: {{ app.ecs.containerport }}
{%     if app.ecs.extra_portmappings is defined %}
{%       for portmapping in app.ecs.extra_portmappings %}
            - ContainerPort: {{ portmapping.container_port }}
{%         if portmapping.host_port is defined %}
              HostPort: {{ portmapping.host_port }}
{%         endif %}
              Protocol: {{ portmapping.protocol | default('tcp') }}
{%       endfor %}
{%     endif %}
          Environment:
            - Name: Application
              Value: "{{ project }}"
{%     for env in app.environment | default([]) %}
            - Name: "{{ env.name }}"
              Value: "{{ env.value }}"
{%     endfor %}
{%     if app.ecs.task_role_arn is defined %}
      TaskRoleArn: "{{ app.ecs.task_role_arn }}"
{%     endif %}

{%     if app.target | lower == 'ecs_scheduled_task' %}
  EventRuleScheduledTask{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::Events::Rule
    Properties:
      Description: Schedule for Scheduled Task for {{ app.cfn_name }}
      ScheduleExpression: "{{ app.execution_schedule | default('cron(0 3 * * ? *)') }}"
      State: ENABLED
      Targets:
      - Arn: !GetAtt ECSCluster.Arn
        Id: Target{{ cfn_project }}{{ app.cfn_name }}
        RoleArn: "{{ app.ecs.task_role_arn }}"
        EcsParameters:
          TaskCount: 1
          TaskDefinitionArn: !Ref Task{{ cfn_project }}{{ app.cfn_name }}
{%     endif %}

{%     if app.target | lower == 'ecs' %}
  ### AWS::ECS::Service for {{ app.name }}
  Service{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: "{{ project }}-{{ app.name }}"
      Cluster: !Ref 'ECSCluster'
      DesiredCount: '{{ app.ecs.desiredcount | default(1) }}'
      ### The DeploymentConfiguration settings are the defaults, they were added
      ### for documentation reasons
      ### Also see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/update-service.html
{%       if app.deploymentconfiguration is defined %}
      DeploymentConfiguration:
        MaximumPercent: {{ app.deploymentconfiguration.max_percent | default(200) }}
        MinimumHealthyPercent: {{ app.deploymentconfiguration.min_healthy_percent | default(100) }}
{%       endif %}
      TaskDefinition: !Ref "Task{{ cfn_project }}{{ app.cfn_name }}"
{%       if app.lb is defined %}
      HealthCheckGracePeriodSeconds: "{{ app.ecs.healthcheckgraceperiodseconds | default(300) }}"
      Role: !Ref 'ECSServiceRole'
      LoadBalancers:
        - ContainerName: "{{ project }}-{{ app.name }}"
          ContainerPort: "{{ app.ecs.containerport }}"
{%         for result in lbstacks.results %}
{%           if result.item.name == app.lb.name %}
{%             if app.lb.targetgroup is defined %}
          TargetGroupArn: "{{ result.stack_outputs[app.lb.targetgroup] }}"
{%             else %}
          TargetGroupArn: "{{ result.stack_outputs['TGApp' + cfn_project + result.item.name + app.cfn_name] }}"
{%             endif %}
{%           endif %}
{%         endfor %}
{%       endif %}

  ### AWS::Route53::RecordSet for {{ app.name }} in private hosted zones
{%       if route53 is defined %}
{%         for result in lbstacks.results %}
{%           if app.domains is defined and result.item.name == app.lb.name %}
{%             for domain in app.domains %}
{%               if domain.skiproute53 is not defined or not domain.skiproute53 %}
  ### {{ result.item.name }} - {{ app.lb.name }} - {{ domain.cfn_name }} - {{ domain.name }}
  Route53RecordSet{{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !ImportValue "{{ cfn_project }}Route53-Route53PrivateHostedZone{{ domain.cfn_name }}"
      Comment: "DNS name for {{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}."
      Name: "{{ domain.listener_rule_host_header }}."
      Type: CNAME
      TTL: '300'
      ResourceRecords:
        - "{{ result.stack_outputs[app.lb.name + 'DNS'] }}"
{%               endif %}
{%             endfor %}
{%           endif %}
{%         endfor %}
{%       endif %}

{%       if app.domains is defined and route53 is defined %}
{%         for domain in app.domains %}
{%           for public_hosted_zone in route53.public_hosted_zones | default([]) %}
{%             if app.lb.type is defined and app.lb.type == 'public' and public_hosted_zone.cfn_name == domain.cfn_name %}
{%               if domain.listener_rule_host_header != domain.name %}
{%                 if domain.skiproute53 is not defined or not domain.skiproute53 %}
  ### Do not create RecordSet if it is same as domainname
  ### AWS::Route53::RecordSet for {{ app.name }} in public hosted zones
  Route53PublicRecordSet{{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}:
    Type: Custom::CNAME
    Properties:
      ServiceToken: {{ public_hosted_zone.sns_arn }}
      Source: {{ domain.listener_rule_host_header }}.
      Target: !ImportValue "{{ cfn_project }}LB{{ app.lb.name }}-{{ app.lb.name }}DNS"
      RecordType: CNAME
{%                 endif %}
{%               endif %}
{%             endif %}
{%           endfor %}
{%         endfor %}
{%       endif %}
{%     endif %}

{%   endif %}
{% endfor %}
