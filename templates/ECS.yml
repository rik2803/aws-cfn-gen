AWSTemplateFormatVersion: '2010-09-09'

Description: |
  Create an ECS stack {{ project }}

### For latest ECS optomized AMIs: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html
Mappings:
  AWSRegionToAMI:
    eu-central-1:
      AMIID: ami-10e6c8fb
    eu-west-1:
      AMIID: ami-c91624b0
    eu-west-2:
      AMIID: ami-3622cf51
    eu-west-3:
      AMIID: ami-ca75c4b7

Resources:

  ### AWS::IAM::Role and AWS::IAM::InstanceProfile
  ECSServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['elasticloadbalancing:DeregisterInstancesFromLoadBalancer', 'elasticloadbalancing:DeregisterTargets',
              'elasticloadbalancing:Describe*', 'elasticloadbalancing:RegisterInstancesWithLoadBalancer',
              'elasticloadbalancing:RegisterTargets', 'ec2:Describe*', 'ec2:AuthorizeSecurityGroupIngress']
            Resource: '*'
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ec2.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"

      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['ecs:CreateCluster', 'ecs:DeregisterContainerInstance', 'ecs:DiscoverPollEndpoint',
              'ecs:Poll', 'ecs:RegisterContainerInstance', 'ecs:StartTelemetrySession',
              'ecs:Submit*', 'logs:CreateLogStream', 'logs:PutLogEvents', 'ecr:GetAuthorizationToken' ]
            Resource: '*'

  AutoscalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [application-autoscaling.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: service-autoscaling
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['application-autoscaling:*', 'cloudwatch:DescribeAlarms', 'cloudwatch:PutMetricAlarm',
              'ecs:DescribeServices', 'ecs:UpdateService']
            Resource: '*'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref 'EC2Role']

  ### Resources for the ECS Cluster and the Container Instances
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: "ecs-{{ project }}"

  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      ImageId: !FindInMap [AWSRegionToAMI, !Ref 'AWS::Region', AMIID]
      SecurityGroups:
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.SGAPP }}"
      InstanceType: "{{ ecs.cluster.instance_type }}"
      IamInstanceProfile: !Ref 'EC2InstanceProfile'
      KeyName: "{{ ecs.cluster.keypair }}"
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
          yum install -y aws-cfn-bootstrap
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}

  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ1 }}"
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ2 }}"
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ3 }}"
      LaunchConfigurationName: !Ref 'ContainerInstances'
      MinSize: '{{ ecs.cluster.cluster_size.min | default('1') }}'
      MaxSize: '{{ ecs.cluster.cluster_size.max | default('1') }}'
      DesiredCapacity: '{{ ecs.cluster.cluster_size.desired | default('1') }}'
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'

  ### Resources for Tasks and Services
{% for app in applicationconfig %}
{%   if app.target | lower == 'ecs' %}
  ### AWS::Logs::LogGroup for {{ app.name }}
  CloudWatch{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "cw-{{ project }}-{{ app.name }}"
      RetentionInDays: 14

  ### AWS::ECS::TaskDefinition for {{ app.name }}
  Task{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: "task-{{ project }}-{{ app.name }}"
      ContainerDefinitions:
        - Name: "{{ project }}-{{ app.name }}"
          Cpu: "{{ app.ecs.cpu | default('10') }}"
          Essential: 'true'
          Image: "{{ app.ecs.image }}"
          Memory: "{{ app.ecs.memory | default(1024) }}"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref "CloudWatch{{ cfn_project }}{{ app.cfn_name }}"
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: "{{ project }}-{{ app.name }}"
          PortMappings:
            - ContainerPort: {{ app.ecs.containerport }}
          Environment:
            - Name: Application
              Value: "{{ project }}"
{%     for env in app.environment | default([]) %}
            - Name: "{{ env.name }}"
              Value: "{{ env.value }}"
{%     endfor %}
{%     if app.ecs.task_role_arn is defined %}
      TaskRoleArn: "{{ app.ecs.task_role_arn }}"
{%     endif %}

  ### AWS::ECS::Service for {{ app.name }}
  Service{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: "{{ project }}-{{ app.name }}"
      Cluster: !Ref 'ECSCluster'
      DesiredCount: '{{ app.ecs.desiredcount | default(1) }}'
      HealthCheckGracePeriodSeconds: "{{ app.ecs.healthcheckgraceperiodseconds | default(300) }}"
      LoadBalancers:
        - ContainerName: "{{ project }}-{{ app.name }}"
          ContainerPort: "{{ app.ecs.containerport }}"
{%     for result in lbstacks.results %}
{%       if result.item.name == app.lb.name %}
{%         if app.lb.targetgroup is defined %}
          TargetGroupArn: "{{ result.stack_outputs[app.lb.targetgroup] }}"
{%         else %}
          TargetGroupArn: "{{ result.stack_outputs['TGApp' + cfn_project + result.item.name + app.cfn_name] }}"
{%         endif %}
{%       endif %}
{%     endfor %}
      Role: !Ref 'ECSServiceRole'
      TaskDefinition: !Ref "Task{{ cfn_project }}{{ app.cfn_name }}"

  ### AWS::Route53::RecordSet for {{ app.name }} in private hosted zones
{%     if route53 is defined %}
{%       for result in lbstacks.results %}
{%         if app.domains is defined and result.item.name == app.lb.name %}
{%           for domain in app.domains %}
{%             if domain.skiproute53 is not defined or not domain.skiproute53 %}
  ### {{ result.item.name }} - {{ app.lb.name }} - {{ domain.cfn_name }} - {{ domain.name }}
  Route53RecordSet{{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !ImportValue "{{ cfn_project }}Route53-Route53PrivateHostedZone{{ domain.cfn_name }}"
      Comment: "DNS name for {{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}."
      Name: "{{ domain.listener_rule_host_header }}."
      Type: CNAME
      TTL: '300'
      ResourceRecords:
        - "{{ result.stack_outputs[app.lb.name + 'DNS'] }}"
{%             endif %}
{%           endfor %}
{%         endif %}
{%       endfor %}
{%     endif %}

{%     if app.domains is defined and route53 is defined %}
{%       for domain in app.domains %}
{%         for public_hosted_zone in route53.public_hosted_zones | default([]) %}
{%           if app.lb.type is defined and app.lb.type == 'public' and public_hosted_zone.cfn_name == domain.cfn_name %}
{%             if domain.listener_rule_host_header != domain.name %}
{%               if domain.skiproute53 is not defined or not domain.skiproute53 %}
  ### Do not create RecordSet if it is same as domainname
  ### AWS::Route53::RecordSet for {{ app.name }} in public hosted zones
  Route53PublicRecordSet{{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}:
    Type: Custom::CNAME
    Properties:
      ServiceToken: {{ public_hosted_zone.sns_arn }}
      Source: {{ domain.listener_rule_host_header }}.
      Target: !ImportValue "{{ cfn_project }}LB{{ app.lb.name }}-{{ app.lb.name }}DNS"
      RecordType: CNAME
{%               endif %}
{%             endif %}
{%           endif %}
{%         endfor %}
{%       endfor %}
{%     endif %}

{%   endif %}
{% endfor %}
